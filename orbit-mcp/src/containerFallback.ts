/**
 * Enhanced container fallback for environments without Docker Sandbox support
 *
 * When microVM sandboxes aren't available (Linux, older Docker Desktop),
 * this module hardens standard containers with security best practices:
 * read-only rootfs, dropped capabilities, no-new-privileges, seccomp,
 * and tmpfs for writable areas.
 */

import { exec as execCallback } from 'child_process';
import { unlink, writeFile } from 'fs/promises';
import { promisify } from 'util';
import { COMPOSE_FILE } from './config.js';

const exec = promisify(execCallback);

export interface FallbackSecurityOptions {
  /** Drop all capabilities (default: true) */
  dropCaps: boolean;
  /** Read-only root filesystem (default: true) */
  readOnlyRoot: boolean;
  /** Disable privilege escalation (default: true) */
  noNewPrivileges: boolean;
  /** Memory limit in MB (default: 2048) */
  memoryLimitMb: number;
  /** CPU limit as fraction (default: 2.0 = 2 cores) */
  cpuLimit: number;
  /** Compose network_mode override (e.g. 'none' for deny-all) */
  networkMode?: 'none' | 'bridge';
}

export const DEFAULT_FALLBACK_SECURITY: FallbackSecurityOptions = {
  dropCaps: true,
  readOnlyRoot: true,
  noNewPrivileges: true,
  memoryLimitMb: 2048,
  cpuLimit: 2.0,
};

/**
 * Generate a docker-compose override YAML that adds security hardening
 * to the existing test runner services.
 */
export function generateSecurityOverride(
  projectType: string,
  opts: FallbackSecurityOptions = DEFAULT_FALLBACK_SECURITY,
): string {
  const lines = [
    '# Auto-generated by Orbit â€” enhanced container security fallback',
    'services:',
    `  test-${projectType}:`,
  ];

  if (opts.networkMode) {
    lines.push(`    network_mode: ${opts.networkMode}`);
  }

  if (opts.readOnlyRoot) {
    lines.push(
      '    read_only: true',
      '    tmpfs:',
      '      - /tmp:size=512M',
      '      - /var/tmp:size=256M',
    );
  }

  if (opts.dropCaps) {
    lines.push('    cap_drop:', '      - ALL');
  }

  if (opts.noNewPrivileges) {
    lines.push('    security_opt:', '      - no-new-privileges:true');
  }

  lines.push(
    '    deploy:',
    '      resources:',
    '        limits:',
    `          memory: ${opts.memoryLimitMb}M`,
    `          cpus: '${opts.cpuLimit}'`,
  );

  return lines.join('\n') + '\n';
}

/**
 * Write a security override file alongside the main compose file
 * and return its path for use with `docker compose -f base -f override`
 */
export async function writeSecurityOverride(
  projectType: string,
  opts: FallbackSecurityOptions = DEFAULT_FALLBACK_SECURITY,
): Promise<string> {
  const content = generateSecurityOverride(projectType, opts);
  const overridePath = COMPOSE_FILE.replace('.yml', '.security-override.yml');
  await writeFile(overridePath, content, 'utf-8');
  return overridePath;
}

/**
 * Run tests using the hardened container fallback.
 * Applies security override on top of the base compose file.
 */
export async function runTestsHardened(
  projectPath: string,
  projectType: string,
  opts: FallbackSecurityOptions = DEFAULT_FALLBACK_SECURITY,
): Promise<{ success: boolean; duration: number; output: string }> {
  const overridePath = await writeSecurityOverride(projectType, opts);
  const startTime = Date.now();

  const envVars = {
    ...process.env,
    PROJECT_PATH: projectPath,
    PROJECT_TYPE: projectType,
  };

  try {
    // Build with base compose
    await exec(
      `docker compose -f "${COMPOSE_FILE}" -f "${overridePath}" --profile ${projectType} build`,
      { env: envVars },
    );

    // Run with security overlay
    const { stdout } = await exec(
      `docker compose -f "${COMPOSE_FILE}" -f "${overridePath}" --profile ${projectType} run --rm test-${projectType}`,
      { env: envVars },
    );

    return { success: true, duration: Date.now() - startTime, output: stdout };
  } catch (error) {
    return {
      success: false,
      duration: Date.now() - startTime,
      output: error instanceof Error ? error.message : String(error),
    };
  } finally {
    try { await unlink(overridePath); } catch { /* cleanup best-effort */ }
  }
}
