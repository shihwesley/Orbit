/**
 * Enhanced container fallback for environments without Docker Sandbox support
 *
 * When microVM sandboxes aren't available (Linux, older Docker Desktop),
 * this module hardens standard containers with security best practices:
 * read-only rootfs, dropped capabilities, no-new-privileges, seccomp,
 * and tmpfs for writable areas.
 */

import { exec as execCallback } from 'child_process';
import { promises as fs } from 'fs';
import { join } from 'path';
import { promisify } from 'util';
import { COMPOSE_FILE } from './config.js';

const exec = promisify(execCallback);

export interface FallbackSecurityOptions {
  /** Drop all capabilities (default: true) */
  dropCaps: boolean;
  /** Read-only root filesystem (default: true) */
  readOnlyRoot: boolean;
  /** Disable privilege escalation (default: true) */
  noNewPrivileges: boolean;
  /** Memory limit in MB (default: 2048) */
  memoryLimitMb: number;
  /** CPU limit as fraction (default: 2.0 = 2 cores) */
  cpuLimit: number;
}

export const DEFAULT_FALLBACK_SECURITY: FallbackSecurityOptions = {
  dropCaps: true,
  readOnlyRoot: true,
  noNewPrivileges: true,
  memoryLimitMb: 2048,
  cpuLimit: 2.0,
};

/**
 * Generate a docker-compose override YAML that adds security hardening
 * to the existing test runner services.
 */
export function generateSecurityOverride(
  projectType: string,
  opts: FallbackSecurityOptions = DEFAULT_FALLBACK_SECURITY,
): string {
  const serviceName = `test-${projectType}`;

  const securityOpts: string[] = [];
  if (opts.noNewPrivileges) securityOpts.push('      - no-new-privileges:true');

  const lines = [
    '# Auto-generated by Orbit â€” enhanced container security fallback',
    'services:',
    `  ${serviceName}:`,
  ];

  if (opts.readOnlyRoot) {
    lines.push('    read_only: true');
    // Need writable tmpfs for /tmp and package manager caches
    lines.push('    tmpfs:');
    lines.push('      - /tmp:size=512M');
    lines.push('      - /var/tmp:size=256M');
  }

  if (opts.dropCaps) {
    lines.push('    cap_drop:');
    lines.push('      - ALL');
  }

  if (securityOpts.length) {
    lines.push('    security_opt:');
    lines.push(...securityOpts);
  }

  lines.push('    deploy:');
  lines.push('      resources:');
  lines.push('        limits:');
  lines.push(`          memory: ${opts.memoryLimitMb}M`);
  lines.push(`          cpus: '${opts.cpuLimit}'`);

  return lines.join('\n') + '\n';
}

/**
 * Write a security override file alongside the main compose file
 * and return its path for use with `docker compose -f base -f override`
 */
export async function writeSecurityOverride(
  projectType: string,
  opts: FallbackSecurityOptions = DEFAULT_FALLBACK_SECURITY,
): Promise<string> {
  const content = generateSecurityOverride(projectType, opts);
  const overridePath = COMPOSE_FILE.replace('.yml', '.security-override.yml');
  await fs.writeFile(overridePath, content, 'utf-8');
  return overridePath;
}

/**
 * Run tests using the hardened container fallback.
 * Applies security override on top of the base compose file.
 */
export async function runTestsHardened(
  projectPath: string,
  projectType: string,
  opts: FallbackSecurityOptions = DEFAULT_FALLBACK_SECURITY,
): Promise<{ success: boolean; duration: number; output: string }> {
  const overridePath = await writeSecurityOverride(projectType, opts);
  const startTime = Date.now();

  const envVars = {
    ...process.env,
    PROJECT_PATH: projectPath,
    PROJECT_TYPE: projectType,
  };

  try {
    // Build with base compose
    await exec(
      `docker compose -f "${COMPOSE_FILE}" -f "${overridePath}" --profile ${projectType} build`,
      { env: envVars },
    );

    // Run with security overlay
    const { stdout } = await exec(
      `docker compose -f "${COMPOSE_FILE}" -f "${overridePath}" --profile ${projectType} run --rm test-${projectType}`,
      { env: envVars },
    );

    return { success: true, duration: Date.now() - startTime, output: stdout };
  } catch (error) {
    return {
      success: false,
      duration: Date.now() - startTime,
      output: error instanceof Error ? error.message : String(error),
    };
  } finally {
    // Clean up override file
    try { await fs.unlink(overridePath); } catch { /* noop */ }
  }
}
